layout(local_size_x = 1) in;

layout(binding = 1, std140) buffer InPosition {
	mat4 inMatrices[];
};

layout(binding = 2, std140) buffer OutPosition {
	mat4 outMatrices[];
};

layout(binding = 3) buffer IndirectBuff {
	uint count;
	uint primCount;
	uint firstIndex;
	uint baseVertex;
	uint baseInstance;
} indirect;

layout(binding = 0) uniform sampler2D texDepth;
uniform mat4 viewProjectMatrix;
uniform float isColor;

void main() {
	uint curIndex = gl_GlobalInvocationID.x;

	mat4 matbb = inMatrices[curIndex];
	mat4 outMat = mat4(matbb[0], matbb[1], matbb[2], vec4(0.0, 0.0, 0.0, 1.0));
	outMat = transpose(outMat);

	if(isColor < 0.1) outMatrices[atomicAdd(indirect.primCount, 1)] = outMat;
	else {
		vec4 curBB = matbb[3];
		vec3 size = curBB.xyz;
		vec3 pose = vec3(outMat[3].x, curBB.w, outMat[3].z);

		vec4 bv0 = vec4(pose + size * vec3( 0.5, 0.5,  0.5), 1.0);
		vec4 bv1 = vec4(pose + size * vec3( 0.5, 0.5, -0.5), 1.0);
		vec4 bv2 = vec4(pose + size * vec3(-1.5, 0.5, -0.5), 1.0);
		vec4 bv3 = vec4(pose + size * vec3(-0.5, 0.5,  0.5), 1.0);

		bv0 = viewProjectMatrix * bv0;
		bv1 = viewProjectMatrix * bv1;
		bv2 = viewProjectMatrix * bv2;
		bv3 = viewProjectMatrix * bv3;

		vec3 t0 = bv0.xyz / bv0.w * 0.5 + 0.5;
		vec3 t1 = bv1.xyz / bv1.w * 0.5 + 0.5;
		vec3 t2 = bv2.xyz / bv2.w * 0.5 + 0.5;
		vec3 t3 = bv3.xyz / bv3.w * 0.5 + 0.5;

		vec4 ocDepth = vec4(texture(texDepth, t0.xy).x,
							texture(texDepth, t1.xy).x,
							texture(texDepth, t2.xy).x,
							texture(texDepth, t3.xy).x);
		vec4 bbDepth = vec4(t0.z, t1.z, t2.z, t3.z);
		vec4 dd = bbDepth - ocDepth;

		if(dd.x > 0.0001 && dd.y > 0.0001 && dd.z > 0.0001 && dd.w > 0.0001) return;
		else outMatrices[atomicAdd(indirect.primCount, 1)] = outMat;
	}
}


